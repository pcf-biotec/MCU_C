/* 

   Biblioteca: Manipulação de LCD à 4 bits
   Autor     : Rahul Martim Juliato
   Compilador: PICC-CCS
   
   Data: 10.12.2012
   Rev.:    03.2017

*/
   
   
/*
Exemplo de utilização:
   
void main(void){

   lcd_ini();          //Inicializa o LCD  
   delay_ms(250);
   lcd_escreve('\f');
   delay_ms(250);

   
   lcd_pos_xy(2,1);    //Utiliza as rotinas de escrita
   printf(lcd_escreve,"LCD");
   lcd_pos_xy(2,2);
   printf(lcd_escreve,"Teste");
   delay_ms(2000);
      
   while(true){
   }
}

*/


/* Original   
#define lcd_enable     pin_D1      // pino enable do LCD
#define lcd_rs         pin_D0      // pino rs do LCD

#define lcd_d4         pin_D2      // pino de dados d4 do LCD
#define lcd_d5         pin_D3      // pino de dados d5 do LCD
#define lcd_d6         pin_D4      // pino de dados d6 do LCD
#define lcd_d7         pin_D5      // pino de dados d7 do LCD
*/

#define lcd_enable     pin_b1      // pino enable do LCD
#define lcd_rs         pin_b0      // pino rs do LCD

#define lcd_d4         pin_b2      // pino de dados d4 do LCD
#define lcd_d5         pin_b3      // pino de dados d5 do LCD
#define lcd_d6         pin_b4      // pino de dados d6 do LCD
#define lcd_d7         pin_b5      // pino de dados d7 do LCD



#define lcd_type 2           // 0=5x7, 1=5x10, 2=2 linhas
#define lcd_seg_lin 0x40    // Endereço da segunda linha na RAM do LCD

// a constante abaixo define a seqüência de inicialização do módulo LCD
byte CONST INI_LCD[4] = {0x20 | (lcd_type << 2), 0xf, 1, 6};


void lcd_envia_nibble( byte dado )
// envia um dado de quatro bits para o display
{
   // coloca os quatro bits nas saidas
   output_bit(lcd_d4,bit_test(dado,0));
   output_bit(lcd_d5,bit_test(dado,1));
   output_bit(lcd_d6,bit_test(dado,2));
   output_bit(lcd_d7,bit_test(dado,3));
   // dá um pulso na linha enable
   output_high(lcd_enable);
   output_low(lcd_enable);
}


void lcd_envia_byte( boolean endereco, byte dado )
{
   // coloca a linha rs em 0
   output_low(lcd_rs);
   // aguarda o display ficar desocupado
   //while ( bit_test(lcd_le_byte(),7) ) ;
   // configura a linha rs dependendo do modo selecionado
   output_bit(lcd_rs,endereco);
   delay_us(100);   // aguarda 100 us
   // caso a linha rw esteja definida, coloca em 0

   // desativa linha enable
   output_low(lcd_enable);
   // envia a primeira parte do byte
   lcd_envia_nibble(dado >> 4);
   // envia a segunda parte do byte
   lcd_envia_nibble(dado & 0x0f);
}


void lcd_ini()
// rotina de inicialização do display
{
   byte conta;
   output_low(lcd_d4);
   output_low(lcd_d5);
   output_low(lcd_d6);
   output_low(lcd_d7);
   output_low(lcd_rs);

   output_low(lcd_enable);
   delay_ms(15);
   // envia uma seqüência de 3 vezes 0x03
   // e depois 0x02 para configurar o módulo
   // para modo de 4 bits
   for(conta=1;conta<=3;++conta)
   {
      lcd_envia_nibble(3);
      delay_ms(5);
   }
   lcd_envia_nibble(2);
   // envia string de inicialização do display
   for(conta=0;conta<=3;++conta) lcd_envia_byte(0,INI_LCD[conta]);
}

void lcd_pos_xy( byte x, byte y)
{
   byte endereco;
   if(y!=1)                      //se y é diferente de 1, muda para segunda linha
      endereco = lcd_seg_lin;
   else
      endereco = 0;
   endereco += x-1;
   lcd_envia_byte(0,0x80|endereco);
}

void lcd_escreve( char c)
// envia caractere para o display
{
   switch (c)
   {
     case '\f'    :   lcd_envia_byte(0,1);
              delay_ms(2);
            break;
     case '\n'   :
     case '\r'    :   lcd_pos_xy(1,2);
              break;
     case '\b'    :   lcd_envia_byte(0,0x10);
              break;
     default   :   lcd_envia_byte(1,c);
              break;
   }
}


